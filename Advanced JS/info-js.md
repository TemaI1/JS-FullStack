*********************************************************************************************************
 
`Rest и Spread` - это два оператора в JS, которые используются для работы с массивами и объектами, но они выполняют разные функции и имеют различные синтаксические особенности.
 
*Rest оператор* (...) используется в функциях и деструктуризации, чтобы собрать оставшиеся элементы в массив или объект.
 
Например:
function sum(first, second, ...others) {
    let total = first + second;
        for (let val of others) {
        total += val;
        }
    return total;
}
console.log(sum(1, 2, 3, 4, 5)); // выводит 15
 
*Оператор spread* (...) используется для развертывания элементов массива или объекта. Он позволяет объединить элементы из одного массива в другой, создать копию массива или объединить свойства объектов.
 
Например:
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // выводит [1, 2, 3, 4, 5, 6]
 
Таким образом, rest оператор используется для сбора неопределенного числа аргументов функции в массив, а spread оператор используется для расширения массивов и объектов или их объединения.
 
*********************************************************************************************************
 
`Деструктуризация` - особенность синтаксиса в JS, позволяет извлекать данные из массивов и объектов, используя более компактный и удобный синтаксис.
 
Например:
let [a, b, c] = [1, 2, 3];
let [a, b, ...other] = [1, 2, 3, 4, 5, 6];
 
*********************************************************************************************************
 
`Несколько основных методов массивов в JavaScript:`
 
`push()`: Добавляет один или несколько элементов в конец массива.
let arr = [1, 2, 3];
arr.push(4, 5);
Теперь массив arr содержит [1, 2, 3, 4, 5]
 
`pop()`: Удаляет последний элемент из массива.
let arr = [1, 2, 3, 4, 5];
let removed = arr.pop();
// Массив arr теперь содержит [1, 2, 3, 4], а переменная removed содержит значение 5
 
`shift()`: Удаляет первый элемент из массива, сдвигая остальные элементы влево.
let arr = [1, 2, 3, 4];
let removed = arr.shift();
// Массив arr теперь содержит [2, 3, 4], а переменная removed содержит значение 1
 
`unshift()`: Добавляет один или несколько элементов в начало массива.
let arr = [1, 2, 3];
arr.unshift(4, 5);
// Теперь массив arr содержит [4, 5, 1, 2, 3]
 
`concat()`: Объединяет два или более массивов, создавая новый массив.
let arr1 = [1, 2];
let arr2 = [3, 4];
let newArr = arr1.concat(arr2);
// Массив newArr содержит [1, 2, 3, 4]
 
`slice()`: Возвращает новый массив, содержащий часть исходного массива от одной точки до другой (не изменяет исходный массив).
let arr = [1, 2, 3, 4, 5];
let slicedArr = arr.slice(1, 3);
// Массив slicedArr содержит [2, 3], исходный массив остается без изменений
 
`splice()`: Изменяет содержимое массива, удаляя или заменяя элементы.
let arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // Удаляет 1 элемент, начиная с позиции 2
// Теперь массив arr содержит [1, 2, 4, 5]
 
`reverse()`: оборачивает порядок элементов в массиве.
`split`: разбивает строку на массив по заданному разделителю.
`join`: создает строку из элементов массива, вставляя между ними разделитель.
 
Методы `find() и findIndex()` предоставляют возможность искать элемент в массиве, первый возвращает значение найденного элемента массива, а второй - его индекс.
 
`Метод find()`:
- Возвращает первый элемент массива, который удовлетворяет условию, если такой элемент не найден, то метод возвращает *undefined*.
- Возвращает значение элемента, а не его индекс.
 
const array = [5, 12, 8, 130, 44];
const found = array.find((element) => element > 10);
// найденное значение будет 12
 
`Метод findIndex()`:
- Возвращает индекс первого элемента массива, который удовлетворяет условию, если такой элемент не найден, то метод возвращает -1.
- Возвращает индекс элемента, а не его значение.
 
const array = [5, 12, 8, 130, 44];
const foundIndex = array.findIndex((element) => element > 10);
// найденное значение будет 1, так как элемент с индексом 1 (значение 12) первый удовлетворяет условию
 
`Метод filter()`: запускает функцию для каждого элемента массива. Все элементы, для которых функция вернула true, помещаются в новый массив и filter возвращает его.
 
Этот метод не изменяет исходный массив, а создает новый массив, содержащий только те элементы, которые прошли фильтрацию.
Функция, передаваемая методу *filter()*, может принимать три аргумента: Элемент, Индекс, Исходный массив.
 
const numbers = [10, 25, 5, 40, 15, 30];
const filteredNumbers = numbers.filter((number) => {
    return number > 20;
});
// filteredNumbers содержит [25, 40, 30], так как они удовлетворяют условию (больше 20)
 
`Метод map()`: вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции, предоставляет удобный способ трансформировать элементы одного массива в новый массив на основе заданных преобразований.
 
const numbers = [1, 2, 3, 4];
const squaredNumbers = numbers.map((number) => {
    return number `` number; // возводит каждый элемент в квадрат
});
// squaredNumbers содержит [1, 4, 9, 16]
 
`Метод sort()`: используется для сортировки элементов массива. Если метод не принимает функцию сравнения, то элементы сортируются в порядке возрастания. 
 
const numbers = [4, 2, 5, 1, 3];
numbers.sort();
console.log(numbers); // Выведет [1, 2, 3, 4, 5]
 
Чтобы отсортировать массив в обратном порядке, необходимо использовать функцию сравнения внутри метода *sort()*:
const numbers = [4, 2, 5, 1, 3];
numbers.sort((a, b) => b - a);
console.log(numbers); // Выведет [5, 4, 3, 2, 1]
 
const fruits = ['apple', 'banana', 'orange', 'grape'];
fruits.sort((a, b) => {
    if (a < b) {
        return 1; // поменять местами, если a меньше b
    }
    if (a > b) {
        return -1; // оставить как есть, если a больше b
    }
    return 0; // равные a и b
});
console.log(fruits); // Выведет ['orange', 'grape', 'banana', 'apple']
 
Для typeof массивы и объекты неотличимы, поэтому статический метод *Array.isArray* помогает определить, является ли переданный объект массивом.
 
*********************************************************************************************************
 
`Несколько основных методов объектов в JavaScript:`
 
`Object.create` создает новый объект с указанным прототипом.
const person = {
    name: "John",
    age: 30
};
const john = Object.create(person);
 
`Object.keys` создает массив ключей объекта.
const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys); // Выведет: ["a", "b", "c"]
 
`Object.values` создает массив значений объекта.
const obj = { a: 1, b: 2, c: 3 };
const values = Object.values(obj);
console.log(values); // Выведет: [1, 2, 3]
 
`Object.entries` создает вложенный массив пар “ключ-значение” объекта.
const obj = { a: 1, b: 2, c: 3 };
const entries = Object.entries(obj);
console.log(entries); // Выведет: [ ["a", 1], ["b", 2], ["c", 3]
 
`Object.assign` копирует значения из одного объекта в другой.
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const result = Object.assign(target, source);
console.log(result); // Выведет: { a: 1, b: 4, c: 5 }
 
`Object.freeze` предотвращает модификацию свойств и значений объекта и добавление или удаление свойств объекта.
const obj = {
    name: "Alice"
};
Object.freeze(obj);
obj.name = "Bob"; // Не сработает, так как объект заморожен
 
`Object.isFrozen` позволяет определить, был ли объект заморожен или нет (возвращает true/false).
const obj = {
    name: "Alice"
};
Object.freeze(obj);
console.log(Object.isFrozen(obj)); // Вернет true
 
`Object.seal` предотвращает добавление новых свойств объекта, но позволяет изменять существующие свойства.
const obj = {
    name: "Bob"
};
Object.seal(obj);
obj.name = "Charlie"; // Работает, так как свойство изменяемо
obj.age = 30; // Не сработает, так как объект запечатан
 
`Object.isSealed` позволяет определить, был ли объект запечатан или нет (возвращает true/false).
const obj = {
    name: "Bob"
};
Object.seal(obj);
console.log(Object.isSealed(obj)); // Вернет true
 
`Object.getPrototypeOf(obj)` возвращает прототип указанного объекта.
const person = {
    name: "Alice",
    age: 25
};
const john = Object.create(person);
console.log(Object.getPrototypeOf(john) === person); // Вернет true
 
`Object.setPrototypeOf(obj, proto)` устанавливает прототип объекта.
const person = {
    name: "Alice",
    age: 25
};
const john = {
    gender: "male"
};
Object.setPrototypeOf(john, person);
console.log(Object.getPrototypeOf(john) === person); // Вернет true
 
*********************************************************************************************************
 
`Prototype`. В JS объекты создаются с использованием конструкторов, которые имеют свой прототип. При создании объекта с помощью конструктора, прототип этого конструктора автоматически становится прототипом созданного объекта. Это обеспечивает наследование свойств и методов от прототипа и является основой прототипного наследования в JS.
 
`Прототип объекта (__proto__)` - это ссылка на прототип, из которого был создан текущий объект. Каждый объект в JavaScript имеет скрытое свойство *__proto__*, которое ссылается на его прототип. Это свойство позволяет объектам обращаться к свойствам и методам, определенным в их прототипах, *__proto__* позволяет получить/установить [[Prototype]] объекта.
 
`Прототип конструктора (Constructor.prototype)` - это свойство, присутствующее у функций-конструкторов. Когда вы создаете новый объект с помощью функции-конструктора, прототип этой функции-конструктора становится прототипом созданного объекта. Это позволяет объектам наследовать методы и свойства, определенные в прототипе функции-конструктора.
 
Отличие между ними заключается в том, что *Constructor.prototype* относится к прототипу функции-конструктора, а *__proto__* относится к прототипу конкретного объекта.
 
*Метод, находящийся в прототипе, имеет контекст (this) того объекта, из которого вызывается.*
 
*Если мы переприсвоим прототип конструктора, то прототипы уже созданных объектов не поменяются.*
 
*Если мы модифицируем прототип конструктора, то прототипы уже созданных объектов поменяются.*
 
*********************************************************************************************************
 
`Примитивы` представляют собой базовые типы данных, такие как строка, число, булево значение, null, undefined, символ. Примитивы имеют встроенные методы и свойства, при обращении к ним будет создан временный объект-обёртка, при обращении к несуществующим полям будет указан undefined.
 
Например, строковый примитив имеет свойства и методы, такие как length (длина строки) и toUpperCase() (преобразование строки в верхний регистр). Числовой примитив имеет методы, такие как toExponential() и toFixed() для форматирования числа.
 
У null и undefined нет объектов-объёрток, именно поэтому обращение к их свойствам вызывает ошибку.
 
*********************************************************************************************************
 
`Прокси` - это объект-обёртка над другим объектом, которая может перехватывать различные действия, связанные с ним. Содержит целевой объект для обертывания и объект-обработчик (содержащий методы(ловушки), для управления поведением).
 
*Всего существует 11 ловушек, с помощью которых мы можем перехватывать различные действия с объектом:*
get(item, propKey, itemProxy) перехватывает операцию чтения свойств объектов.
set(item, propKey, value, itemProxy) перехватывает операцию установки свойств объектов.
has(item, propKey) перехватывает операцию propKey in objProxy.
deleteProperty(item, propKey) перехватывает операцию delete.
ownKeys(item) перехватывает такие операции, как Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy), for...in.
getOwnPropertyDescriptor(item, propKey) перехватывает операцию Object.getOwnPropertyDescriptor(proxy, propKey).
defineProperty(item, propKey, propDesc) перехватывает такие операции, как Object.defineProperty(proxy, propKey, propDesc, Object.defineProperties(proxy, propDescs).
preventExtensions(item) перехватывает операцию Object.preventExtensions(proxy).
getPrototypeOf(item) перехватывает операцию Object.getPrototypeOf(proxy).
setPrototypeOf(item, proto) перехватывает операцию Object.setPrototypeOf(proxy, proto).
isExtensible(item) перехватывает операцию Object.isExtensible(proxy).
 
*Если целевой объект является функцией, то существуют 2 дополнительные операции для перехвата:*
apply(item, context, args) перехватывает операции вызова функции, такие как proxy(...args), proxy.call(context, ...args), proxy.apply(...).
construct(item, args) перехватывает операцию, запускаемую экземпляром прокси-объекта в качестве конструктора, а именно new proxy(...args).
 
*Объект Reflect* нужен для того, чтобы в прокси обработчике сделать стандартное действие с объектом, имеет такое же имя и те же аргументы, что и у ловушки Proxy.
 
*Можно использовать прокси для реализации обращения по отрицательным индексам массива следующим образом:*
const negativeArrayHandler = {
    get: function(target, prop) {
        if (parseInt(prop) < 0) {
            // При обращении к отрицательному индексу возвращаем элемент массива от конца
            return target[target.length + parseInt(prop)];
        } else {
            return target[prop];
        }
    }
};
 
const array = [1, 2, 3, 4, 5];
const negativeArray = new Proxy(array, negativeArrayHandler);
 
console.log(negativeArray[-1]); // 5 (последний элемент массива)
console.log(negativeArray[-2]); // 4 (предпоследний элемент массива
 
*********************************************************************************************************
 
`Генераторы` - это функции, которые могут порождать множество значений одно за другим по мере того, как мы их вызываем. Для создания генератора используется специальная функция, объявленная как *function**.
 
Тело функции начинает выполняться когда у возвращенного генератора вызовется метод *next()* и будет выполняться до первого *yield*, последнее значение указывается *return*.
 
Значения, выдаваемые генераторами, можно перебирать в цикле *for of* (только необходимо помнить, что последнее значение возвращаемое *return* проитерировано не будет).
 
*Создадим генератор, который будет выдавать числа, возведенные в степень 2:*
function* generatePowersOfTwo() {
    let power = 0;
    while (true) {
        yield Math.pow(2, power);
        power++;
    }
}
 
let powerGenerator = generatePowersOfTwo();
 
console.log(powerGenerator.next().value); // 1
console.log(powerGenerator.next().value); // 2
console.log(powerGenerator.next().value); // 4
console.log(powerGenerator.next().value); // 8
 
*********************************************************************************************************