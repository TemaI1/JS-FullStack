*********************************************************************************************************
 
Обычно `JavaScript обрабатывается в одном потоке`. Это означает, что только одна часть кода JavaScript может выполняться в один момент времени. Однако с использованием веб-рабочих потоков (Web Workers) можно создавать дополнительные потоки для обработки определенных задач, что позволяет выполнять асинхронные операции без блокировки основного потока выполнения кода.
 
`Асинхронное программирование` - это подход к организации кода, при котором операции выполняются независимо друг от друга, то есть одна операция может выполняться в то время, когда другая уже завершилась или еще не началась.
 
Асинхронное программирование в JavaScript достигается с помощью колбэков (callback функций), промисов (promises), и асинхронных функций (async/await). Это позволяет выполнять операции в фоновом режиме, не блокируя основной поток выполнения кода.
 
*********************************************************************************************************
 
`Callback функции` - это функции в JavaScript, которые передаются в качестве аргументов в другие функции и вызываются после выполнения определенной операции или события.
 
Callback функции особенно полезны в асинхронном программировании, когда код должен ждать завершения определенной операции, такой как загрузка данных из сервера или выполнение анимации, прежде чем продолжить выполнение. Функция обратного вызова позволяет указать, что нужно сделать после завершения операции, и тем самым предотвратить блокирование основного потока выполнения.
 
Также callback функции широко используются в обработке событий, таймерах, AJAX запросах, обработке ошибок и многих других сценариях. Они позволяют динамически управлять выполнением кода в зависимости от различных условий и событий.
 
`Адом колбэков (callback hell)` - когда асинхронный код в JavaScript содержит множество вложенных колбэков, что делает его неподдерживаемым и тяжело читаемым. Код становится пирамидой вложенных вызовов функций, что затрудняет понимание логики, управляющей асинхронными операциями и их результатами.
 
*********************************************************************************************************
 
`Промисы (promises)` в JavaScript - это объекты, используемые для выполнения асинхронных операций и управления их результатами. Они являются частью асинхронного программирования в JavaScript и представляют собой альтернативный способ работы с асинхронными задачами по сравнению с использованием колбэк функций.
 
Промисы имеют три состояния:
1. Ожидание (pending) - начальное состояние, при котором промис ожидает завершения операции.
2. Выполнено (fulfilled) - состояние, при котором операция завершилась успешно.
3. Отклонено (rejected) - состояние, при котором операция завершилась с ошибкой.
 
Промис создается с помощью конструктора *Promise*, который принимает функцию-исполнитель (executor) в качестве аргумента. Эта функция-исполнитель принимает два аргумента: *resolve* (работа завершилась успешно) и *reject* (произошла ошибка).
 
Пример создания промиса:
let myPromise = new Promise((resolve, reject) => {
let success = true; // предположим, что запрос был успешным
if (success) {
resolve("Успех!"); // разрешение промиса
} else {
reject("Ошибка!"); // отклонение промиса
}
});
 
После создания промиса можно цеплять обработчики для состояний разрешения и отклонения с помощью методов *then* (для успешного разрешения) и *catch* (для отклонения).
 
Пример обработки промиса:
myPromise.then((result) => {
console.log(result); // выводится "Успех!", если промис разрешен успешно
}).catch((error) => {
console.log(error); // выводится "Ошибка!", если промис был отклонен
});
 
Использование промисов облегчает управление асинхронным кодом и обработку результатов таких операций, делая код более читаемым и поддерживаемым.
 
*********************************************************************************************************
 
`Исполнитель (executor) промиса.` Исполнитель промиса может оповестить вызывающий код о завершении своей работы путем вызова функций *resolve* или *reject*, которые передаются исполнителю в качестве аргументов. Когда операция, выполненная исполнителем промиса, завершается, он вызывает одну из этих функций, в зависимости от того, успешно ли завершилась операция.
 
- Если операция прошла успешно, исполнитель вызывает функцию *resolve* с результатом выполненной операции в качестве аргумента.
- Если произошла ошибка или операция завершилась неуспешно, исполнитель вызывает функцию *reject* с объектом ошибки в качестве аргумента.
 
После того как функция *resolve* или *reject* вызвана, промис переходит в соответствующее состояние (успешного разрешения или отклонения), и затем срабатывают соответствующие обработчики, установленные с помощью методов *then* и *catch*.
 
Итак, исполнитель промиса может оповестить вызывающий код об успешном завершении или об ошибке, вызывая соответствующие функции *resolve* или *reject*, что позволяет дальше обрабатывать результаты асинхронной операции в асинхронных цепочках промисов.
 
*********************************************************************************************************
 
`Обработчики промиса.` Вызывающий код может отслеживать выполнение промиса и обрабатывать его результаты с помощью методов *then*, *catch* и *finally*, можно объединять эти методы в цепочку для последовательной обработки результатов промиса.
 
- Метод *then* используется для обработки успешного разрешения промиса. Он принимает два аргумента: функцию обратного вызова, которая будет выполнена в случае успешного разрешения промиса, и функцию обратного вызова, которая будет выполнена в случае возникновения ошибки.
- Метод *catch* используется для обработки отклонения промиса. Этот метод принимает только один аргумент - функцию обратного вызова, которая будет выполнена в случае отклонения промиса. Пример:
- Метод *finally* используется для выполнения определенной логики независимо от того, был ли промис успешно разрешен или отклонен. Этот метод принимает функцию обратного вызова, которая будет выполнена после завершения работы промиса.
 
Таким образом, вызывающий код может отслеживать выполнение промиса и обрабатывать его результаты, учитывая успешное разрешение, отклонение и выполнение определенной логики после завершения работы промиса.
 
*********************************************************************************************************
 
`Цепочки промисов` в JavaScript можно реализовать путем последовательного вызова методов *then* и *catch*, которые позволяют продолжать обработку результатов промиса и передавать эти результаты от одного обработчика к другому. 
 
Пример реализации цепочки промисов:
- Создаем первый промис
let firstPromise = new Promise((resolve, reject) => {
resolve(10);
});
- Создаем второй промис, который использует результат первого промиса
let secondPromise = firstPromise.then((result) => {
console.log("Первый промис успешно разрешен:", result);
return result `` 2; // Возвращаем результат для передачи в следующий обработчик
});
- Создаем третий промис, который использует результат второго промиса
let thirdPromise = secondPromise.then((result) => {
console.log("Второй промис успешно разрешен:", result);
return result + 5; // Возвращаем результат для передачи в следующий обработчик
});
- Обработка ошибок в цепочке промисов
thirdPromise.catch((error) => {
console.log("Произошла ошибка в цепочке промисов:", error);
});
 
В этом примере мы создаем цепочку из трех промисов: *firstPromise*, *secondPromise* и *thirdPromise*. Результат первого промиса используется для обработки вторым и так далее. В каждом обработчике *then* мы можем изменять или обрабатывать результат и возвращать его для последующего использования.
 
Таким образом, цепочки промисов делают возможным последовательное выполнение асинхронных операций и передачу результатов между ними, что позволяет структурировать асинхронный код более читаемым и удобным образом.
 
*********************************************************************************************************
 
`Thenable` - это объект, который содержит метод *then*, должен реализовывать метод *then*. Метод *then* принимает две функции обратного вызова: одну для обработки успешного разрешения промиса, и другую для обработки отклонения промиса.
 
Использование thenable позволяет расширить возможности работы с промисами, позволяя другим объектам вести себя подобно промисам, что способствует более гибкой и модульной асинхронной обработке данных.
 
*********************************************************************************************************
 
`Неявный try...catch` отлавливает ошибки в асинхронном коде и передает их в обработчики отклонения промиса. Это означает, что если происходит ошибка в исполнителе промиса или в обработчиках промиса (в методах *then*, *catch*, и т.д.), то эта ошибка будет автоматически передана в обработчики отклонения промиса для обработки. Внутри промиса происходит неявный *try...catch*, который ловит исключения и отклоняет промис с этой ошибкой.
 
Таким образом, неявный *try...catch* обеспечивает более безопасную и удобную обработку ошибок в асинхронном коде, улучшая понимание и отладку сложной асинхронной логики.
 
*********************************************************************************************************
 
Методы `Promise.all` и `Promise.allSettled` оба используются для работы с несколькими промисами, но существуют определенные различия в том, как они обрабатывают результаты и ошибки.
 
*Promise.all* ожидает, пока все промисы из массива завершатся - либо успешно, либо с ошибкой. Если хотя бы один из промисов отклоняется, то *Promise.all* сразу же отклоняется с этой ошибкой, и результаты остальных промисов игнорируются. В случае успешного завершения всех промисов, *Promise.all* возвращает массив результатов этих промисов в том порядке, в котором они были переданы.
 
*Promise.allSettled* ожидает завершения всех промисов из массива, независимо от их успешности или ошибочности. По завершении всех промисов *Promise.allSettled* возвращает массив объектов, содержащих информацию о состоянии каждого промиса: *{status: 'fulfilled', value: result}* для успешных промисов и *{status: 'rejected', reason: error}* для отклоненных промисов.
 
Итак, основное различие между *Promise.all* и *Promise.allSettled* заключается в том, что *Promise.all* останавливается при первой ошибке и возвращает ошибку, в то время как *Promise.allSettled* дожидается завершения всех промисов и возвращает результаты всех промисов, вместе с информацией о том, успешно они завершились или нет.
 
*Promise.race* возвращает выполненный или отклонённый промис, в зависимости от того, какой отработал быстрее, со значением или причиной отклонения этого промиса.
 
*********************************************************************************************************
 
`async` используется для создания асинхронных функций, позволяет определить функцию, которая работает асинхронно, используя промисы для управления асинхронными операциями. 
 
Вот что делает и зачем нужно ключевое слово *async*:
- Когда функция объявлена с ключевым словом *async*, она может содержать оператор *await*.
- *async* позволяет использовать современные возможности JavaScript, связанные с промисами, для обработки асинхронного кода. Это делает код более читаемым и понятным, особенно при выполнении последовательных асинхронных операций.
- *async* прекрасно работает с обработкой исключений при помощи обычных конструкций *try...catch*. Это позволяет прозрачно обрабатывать ошибки в асинхронном коде.
- *async* упрощает написание кода, особенно в случаях, когда необходимо выполнить несколько асинхронных операций или управлять асинхронными вызовами функций.
 
Ключевое слово *async* является важным инструментом для управления асинхронными операциями в JavaScript, и оно делает код более удобным, понятным и безопасным для выполнения сложных асинхронных задач.
 
`await` используется в контексте асинхронного программирования и вводится вместе с ключевым словом *async*. 
 
Вот что делает и зачем нужно ключевое слово *await*:
- *await* используется для приостановки выполнения функции до момента разрешения или отклонения промиса. Код блокируется, пока промис не завершится, и затем *await* возвращает результат этого промиса.
- *await* делает код более линейным и читаемым, особенно при выполнении последовательности асинхронных операций. Вместо цепочки вызовов *then* методов, *await* позволяет писать асинхронный код более похожим на синхронный.
- *await* также позволяет легко обрабатывать ошибки, используя обычную конструкцию *try...catch*, что делает синтаксис для обработки ошибок в асинхронном коде более удобным.
 
Где нельзя использовать *await*:
- *await* может использоваться только внутри тела асинхронной функции, обозначенной ключевым словом *async*. Попытка использовать *await* вне такой функции приведет к синтаксической ошибке.
- *await* не может быть использован в глобальной области видимости, так как этот контекст не позволяет выполнение асинхронного кода.
 
Таким образом, *await* является чрезвычайно полезным инструментом для управления асинхронными операциями и обработки промисов, но он имеет свои ограничения по использованию.
 
*********************************************************************************************************
 
`Event Loop (цикл событий)` - отвечает за обработку и выполнение асинхронного кода, обработку событий и управление порядком выполнения операций в JS.
 
Схема работы Event Loop:
1. Обрабатываются все синхронные операции, которые могут быть выполнены немедленно.
2. Если встречается асинхронная операция (таймер или обработчик события), она поступает в очередь асинхронных операций (Event Queue) вместе с колбэком, который должен быть вызван после завершения этой операции.
3. Event Loop извлекает из очереди операции и передает на выполнение.
4. Асинхронная операция отправляется на выполнение, и JS-движок ожидает ее завершения. В то же время Event Loop вновь проверяет очередь асинхронных операций и продолжает этот процесс, пока очередь не опустеет.
5. По завершении асинхронной операции вызывается соответствующий колбэк, который был прикреплен к этой операции.
6. Event Loop выполняет цикл проверки очереди асинхронных операций и выполнения их колбэков, пока в очереди присутствуют операции.
 
Таким образом, Event Loop является механизмом, который обеспечивает недопущение блокировки выполнения JavaScript из-за асинхронных операций, управляя порядком выполнения асинхронного кода и обеспечивая неблокирующую асинхронную модель исполнения.
 
*********************************************************************************************************
 
`Микрозадачи и макрозадачи` - задачи Event Loop, по своей сложности и времени выполнения. После каждой макрозадачи браузер выполняет микрозадачи и рендеринг страницы.
 
Микрозадачи обычно выполняются быстро и имеют небольшой объем работы. Они могут выполняться сразу после выполнения текущего кода. Примеры микрозадач включают в себя обновление интерфейса, отправку AJAX-запросов и обработку пользовательского ввода.
 
Макрозадачи, напротив, выполняются более длительное время и требуют более длительной обработки. Примеры макрозадач включают в себя загрузку больших файлов, вычисление сложных алгоритмов и отправку больших объемов данных на сервер.
 
Чтобы добавить микрозадачи и макрозадачи в очередь выполнения в JS, мы можем использовать методы промисов и асинхронных функций. Для микрозадач мы можем использовать метод *Promise.resolve()*, который добавляет задачу в очередь выполнения последующего кода. Для макрозадач мы можем использовать асинхронные функции и ключевое слово *async*, которые позволяют добавить длинные операции в очередь выполнения, не блокируя основной поток выполнения.
 
*********************************************************************************************************
 
`Ajax` (Asynchronous JavaScript and XML) - используется для отправки и получения данных с сервера без необходимости перезагрузки всей веб-страницы. Позволяет обмениваться данными между браузером и сервером асинхронно.
 
Для реализации Ajax в JS используются функции XMLHttpRequest или fetch(). После отправки запроса на сервер, JS может обрабатывать ответ и обновлять содержимое веб-страницы на основе полученных данных.
 
AJAX не поддерживает полнодуплексную связь(передавать и принимать данные одновременно в обе стороны), поэтому для интенсивного обмена данных с сервером вместо AJAX используется WebSockets.
 
*********************************************************************************************************
 
`XMLHttpRequest и fetch` - это два главных способа выполнения HTTP запросов в JS для получения данных с сервера. Они оба позволяют делать запросы к серверу и обрабатывать полученные от него данные, но есть несколько ключевых различий между ними:
 
- XMLHttpRequest работает на основе колбэков, а fetch, работает на основе промисов.
- В XMLHttpRequest необходимо явно указывать тип запроса (GET, POST, PUT и т.д.), а также устанавливать заголовки запроса, а в fetch эти параметры указываются в опциях запроса.
- Fetch поддерживается не всеми старыми браузерами, в то время как XMLHttpRequest имеет более широкую поддержку.
 
В целом, fetch - это более современный и удобный способ выполнения HTTP запросов в JS, предоставляющий более простой и гибкий интерфейс, в то время как XMLHttpRequest используется в старых проектах и может быть менее удобным в использовании из-за своей более громоздкой структуры.
 
fetch методы получения данных: result.text(), result.json(), result.formData(), result.blob(), result.arrayBuffer().
 
У fetch существует необязательный второй параметр options. Если он не указан, то fetch совершает обычный GET запрос на получение файла, указанного первым параметром.
Возможные опции: method (метод запроса), headers (заголовки запроса в виде JS объекта), body (тело запроса). 
body может иметь вид: строки (JSON или urlencoded), объекта FormData, Blob/BufferSource.
 
*********************************************************************************************************
 
`WebSockets` - предоставляет двустороннюю коммуникацию между клиентом и сервером через одно соединение TCP. Это позволяет установить постоянное и непрерывное соединение между клиентом и сервером, для обмена данными в режиме реального времени.
 
WebSockets особенно удобны для асинхронной коммуникации и обмена потоковыми данными. Они также обладают возможностью отправки пакетов данных в обоих направлениях, в отличие от HTTP-запросов, которые требуют установления нового соединения для каждого запроса.
 
Данные можно отправлять в любой момент, вызвав метод send.
Работа WebSocket в JS: запуск ws соединения, установка 4 колбеков(на установку/разрыв соединения, получение данных и ошибку).
 
*********************************************************************************************************
 
`localStorage и sessionStorage` - это два важных механизма для хранения данных в браузере.
 
Хранилище привязано к источнику (домен/протокол/порт). Для каждой комбинации этих трёх параметров будет уникальный Local Storage.
 
- localStorage: Данные, сохраненные в localStorage, остаются сохраненными даже после закрытия браузера и могут быть использованы при последующих заходах на сайт. Они сохраняются навсегда, пока явно не будут удалены.
- sessionStorage: Данные, сохраненные в sessionStorage, доступны только в течение одной сессии браузера (пока вкладка или окно браузера открыты). Когда сессия завершается (пользователь закрывает вкладку или окно), данные удаляются.
- localStorage: Данные в localStorage доступны в рамках всего домена, на который они были сохранены. Это означает, что они доступны для всех страниц на этом домене.
- sessionStorage: Данные в sessionStorage доступны только в рамках конкретной вкладки браузера. Они не доступны в других вкладках.
- localStorage: Обычно более вместительный (обычно около 5-10 МБ) и позволяет хранить большее количество данных.
- sessionStorage: Обычно имеет меньший лимит (обычно около 5 МБ) и предназначен для временного хранения небольших объемов данных в рамках одной сессии.
 
Оба механизма основаны на ключ-значение и обеспечивают простой способ сохранения и получения данных в браузере, но их различия в области видимости, длительности хранения и лимитах.
 
Объект хранилища localStorage имеет методы и свойства:
setItem(key, value) – сохранить пару ключ/значение
getItem(key) – получить данные по ключу 
keyremoveItem(key) – удалить данные с ключом 
keyclear() – удалить всё
key(index) – получить ключ на заданной позиции
length – количество элементов в хранилище
 
*********************************************************************************************************