*********************************************************************************************************
 
`Cложность алгоритма` - количество вычислительных ресурсов (таких как время и память) необходимых для выполнения алгоритма. Она учитывает, как алгоритм будет вести себя при увеличении объема входных данных.
 
Существует два вида сложности: временная сложность, которая измеряется в количестве действий, необходимых для выполнения алгоритма, и пространственная сложность, которая оценивает объем памяти, необходимый для выполнения алгоритма. 
 
Сложность алгоритма часто представляется в виде "O-нотации" (например, O(n) или O(n^2)), которая позволяет оценить, как изменится время выполнения алгоритма при изменении размера входных данных.
 
*********************************************************************************************************
 
`Linked list (связанный список)` - это структура данных, состоящая из узлов, каждый из которых содержит данные и указатель на следующий узел в списке. Она отличается от массива тем, что не требует непрерывного распределения памяти и может динамически изменять свой размер.
 
Linked list используется, когда требуется эффективная вставка или удаление элементов в середине списка, так как это можно сделать, не копируя или перемещая другие элементы списка.
 
Сложность операций на связанном списке следующая:
1. Поиск: В худшем случае O(n), так как при поиске элемента нужно последовательно просматривать весь список.
2. Вставка/удаление: O(1), если имеется указатель на узел, перед или после которого нужно произвести вставку/удаление. Все операции выполняются только для узлов, которые нужно изменить, и не требуют перемещения остальных элементов списка.
 
Итак, связанный список эффективен для вставки и удаления элементов, особенно в середине списка, но не так эффективен для поиска элементов.
 
*********************************************************************************************************
 
`Стек (stack)` - элементы добавляются и удаляются только с одного конца стека, называемого вершиной стека.
 
Стек используется в таких случаях, когда требуется временное хранение данных в порядке обратном тому, в котором они были добавлены. Например, при обработке операций или рекурсивных вызовах функций.
 
Сложность операций на стеке:
1. Добавление элемента (push): O(1). Так как элемент всегда добавляется на вершину стека, то сложность операции добавления константная.
2. Удаление элемента (pop): O(1). Удаление элемента также происходит с вершины стека и имеет константную сложность.
 
stack.push() – добавление элемента в стек
stack.pop() – удаление элемента с вершины стека
stack.peek() – возвращает значение элемента на вершине стека
stack.size – количество элементов
 
Таким образом, стек эффективен для операций добавления и удаления элементов и обычно имеет постоянное время выполнения для этих операций.
 
*********************************************************************************************************
 
`Очередь (queue)` - элементы добавляются в конец очереди, а удаляются из её начала. Очередь используется в ситуациях, когда необходимо управлять элементами в порядке их поступления.
 
Сложность операций на очереди:
1. Добавление элемента (enqueue): O(1). Так как элемент всегда добавляется в конец очереди, то операция добавления имеет постоянную сложность.
2. Удаление элемента (dequeue): O(1). Удаление элемента из начала очереди также имеет постоянную сложность.
 
queue.enqueue() – добавление элемента в конец очереди
queue.dequeue() – удаление элемента из начала очереди
queue.peek() – возвращает значение элемента из начала очереди
queue.size – количество элементов
 
Таким образом, очередь также эффективна для операций добавления и удаления элементов и обычно имеет постоянное время выполнения для этих операций.
 
*********************************************************************************************************
 
`Двусторонняя очередь (deque)` - сочетает в себе свойства стека и очереди. Она позволяет добавлять и удалять элементы как с начала, так и с конца структуры данных.
 
Двусторонняя очередь используется, когда требуется эффективный доступ и модификации исходных данных как в начале, так и в конце структуры. Например, при построении систем обработки событий, когда могут возникать задачи инициированные как с начала, так и с конца.
 
Сложность операций на двусторонней очереди:
1. Добавление элемента:
- В начало (push_front): O(1), поскольку элемент просто добавляется в начало структуры данных, и операция имеет постоянную сложность.
- В конец (push_back): O(1), так как элемент добавляется в конец структуры данных, и операция имеет постоянную сложность.
2. Удаление элемента:
- Из начала (pop_front): O(1), поскольку элемент удаляется из начала структуры, и операция имеет постоянную сложность.
- Из конца (pop_back): O(1), так как удаление элемента из конца структуры данных также имеет постоянную сложность.
 
Таким образом, двусторонняя очередь обеспечивает эффективные методы добавления и удаления элементов как в начале, так и в конце структуры, и операции обычно имеют постоянное время выполнения.
 
*********************************************************************************************************
 
`Двоичное дерево поиска (Binary Search Tree, BST)` - это структура данных, состоящая из узлов, в которой каждый узел имеет не более двух потомков, и при этом левый потомок имеет значение меньше родительского узла, а правый потомок - больше.
 
Двоичные деревья поиска обеспечивают эффективный способ хранения и поиска данных. Они широко используются для реализации структур данных, таких как упорядоченные множества и ассоциативные массивы (map), поскольку эффективно поддерживают операции вставки, удаления и поиска элементов.
 
Сложность операции поиска элемента в двоичном дереве поиска - в среднем O(log n), где n - количество узлов в дереве. Однако в худшем случае, когда дерево несбалансировано, сложность может достигать O(n). 
 
Таким образом, эффективность двоичного дерева поиска зависит от структуры дерева и способов его балансировки.
 
`Tree (Дерево)` – структура данных, эмулирующая древовидную структуру в виде набора связанных узлов.
Каждый узел содержит значение и ссылки на дочерние узлы.
Узлы, у которых нет дочерних узлов, называются листьями.
Самый верхний узел – корень.
Высота узла – количество ребер от этого узла до дальнейшего узла.
Высота дерева равна высоте корня.
Глубина узла – количество ребер от корня до узла.
 
*********************************************************************************************************
 
`Depth-First Search (DFS) и Breadth-First Search (BFS)` - это два основных алгоритма обхода графа. Они отличаются в порядке обхода вершин и способе организации посещения вершин.
 
1. Depth-First Search (DFS):
- При обходе графа с помощью DFS начинается с выбора одной вершины и затем переходится к любой непосещенной смежной вершине.
- По этому принципу DFS "погружается" настолько глубоко, насколько это возможно, прежде чем возвращаться к поиску других вершин.
- DFS обычно реализуется с использованием рекурсии, что позволяет "погружаться" вместо того, чтобы распределиться как в BFS.
- DFS часто используется при поиске глубины, топологической сортировке, поиске компонент связности.
 
2. Breadth-First Search (BFS):
- При обходе графа с помощью BFS начинается с выбора одной вершины и затем посещаются все смежные вершины.
- Затем для каждой из смежных вершин идет обход их смежных вершин, и так далее.
- BFS "распространяется" равномерно от начальной вершины ко всем ее смежным вершинам, в ширину.
- BFS часто используется при поиске кратчайшего пути или поиске в ширину, когда нужно найти кратчайший путь от одной вершины к другой.
 
Для обоих алгоритмов важно помечать посещенные вершины, чтобы избежать зацикливания в случае наличия ребер возвратной связи.
 
*********************************************************************************************************
 
`Граф (Graph)` - структура данных, которая состоит из вершин (узлов) и рёбер (связей) между этими вершинами. Граф представляет собой модель, в которой объекты (вершины) связаны между собой.
 
`Взвешенный граф` – граф, ребрам которого поставлено в соответствие некое значение (вес ребра).
 
`Матрица смежности (Adjacency Matrix)` - это двумерная квадратная матрица, где значение в ячейке (i, j) указывает на наличие или отсутствие ребра между вершинами i и j. В неориентированном графе, матрица смежности будет симметричной относительно главной диагонали по оси i = j. Для взвешенных графов, в матрице также может храниться вес ребра. Матрица смежности хорошо подходит для поиска связей между вершинами, но требует O(V^2) памяти, где V - количество вершин.
 
`Список смежности (Adjacency Lists)` представляют граф в виде массива списков или хеш-таблиц, где каждый список соответствует вершине, а элементы списка - её соседи. В неориентированном графе, обычно каждое ребро добавляется дважды, по одному разу для каждой вершины, между которой оно проходит. Основное преимущество списков смежности в том, что они занимают O(V + E) памяти, где V - количество вершин, E - количество рёбер, что делает их более эффективными для разреженных графов.
 
Оба варианта представления графа - матрица смежности и списки смежности - имеют свои достоинства и недостатки и выбор между ними обычно зависит от конкретных задач и особенностей входных данных.
 
*********************************************************************************************************
 
`Алгоритм Дейкстры` - это алгоритм нахождения кратчайших путей от одной из вершин неориентированного взвешенного графа до всех остальных. Данный алгоритм был разработан нидерландским ученым Эдсгером Дейкстрой в 1956 году.
 
Алгоритм Дейкстры решает задачу о нахождении кратчайшего пути от начальной вершины до всех остальных вершин в неориентированном взвешенном графе. В процессе выполнения алгоритма от начальной вершины к каждой другой находится кратчайшее расстояние, при этом строится дерево кратчайших путей.
 
Основные шаги алгоритма Дейкстры:
1. Инициализация. Устанавливаем начальные значения расстояний до всех вершин, начальной вершине ставим расстояние 0, а до остальных вершин - бесконечность. Также создаем множество вершин, у которых еще не найдено кратчайшее расстояние.
2. Выбираем вершину с минимальным расстоянием из множества вершин.
3. Обновляем расстояния до смежных вершин, если новое расстояние меньше предыдущего.
4. Повторяем шаги 2 и 3, пока есть не обработанные вершины.
 
Сложность алгоритма Дейкстры зависит от используемой структуры данных для хранения вершин и ребер графа. В случае использования мин-кучи для поиска вершины с минимальным расстоянием, сложность алгоритма составляет O((V + E) `` log V), где V - количество вершин, E - количество ребер.
 
*********************************************************************************************************
 
"Map" и "Set" служат для представления и работы с данными.
 
`"Map"` - это коллекция, позволяющая хранить данные в формате ключ-значение. Она позволяет использовать любые значения в качестве ключей, в том числе и объекты, и предоставляет возможность быстрого доступа к данным по ключу.
 
map.set(key, value) – записывает значение value по ключу key
map.get(key, value) – возвращает значение value по ключу или undefined, если ключ отсутствует
map.has(key) – возвращает true, если ключ присутствует в коллекции, иначе false
map.delete(key) – удаляет элемент по ключу key
map.clear() – очищает map
map.size – возвращает количество элементов
map.keys() – возвращает итератор по ключам
map.values() – возвращает итератор по значениям
map.entries() – возвращает итератор по парам вида (ключ, значение)
 
`"Set"` - это коллекция, хранящая уникальные значения любого типа. Она предоставляет простой способ хранения уникальных значений и эффективно управляет повторяющимися данными.
 
set.add(value) – добавляет элемент value в набор, возвращает set. Если элемент уже существует, то ничего не произойдет
set.delete(value) – удаляет элемент из множества, возвращает true, если он там был, иначе false●set.has(value) – возвращает true если value есть в коллекции, иначе false
set.clear() – очищает set
set.size – возвращает количество элементов
set.values() – возвращает итератор для значений
set.keys() – то же самое, что и set.values()
set.entries() – возвращает итератор  для пар вида (значение, значение)
 
Кроме добавления и доступа к данным, со структурами Map и Set можно проводить операции проверки наличия элементов, удаления, перебора элементов с помощью циклов и другие манипуляции. Обе структуры предоставляют значительное преимущество в скорости доступа к данным по сравнению с исользованием объектов или массивов для аналогичных целей, а также предоставляют возможность более эффективной проверки уникальности элементов в списке и выполнения операций над множествами.
 
*********************************************************************************************************
 
`Паттерны проектирования (Design Patterns)` - это повторяемые решения типичных проблем, возникающих в процессе разработки программного обеспечения.
 
Паттерны проектирования полезны по нескольким причинам:
Стандартизация: Паттерны предоставляют решения для типичных проблем, стандартизируя подход к проектированию программных систем.
Повышение производительности: Использование паттернов позволяет уменьшить время разработки и повысить эффективность программного кода.
Общий язык: Паттерны предоставляют унифицированный язык, с помощью которого разработчики могут обсуждать и документировать свои решения.
 
Паттерны проектирования делятся на три основные группы:
Порождающие – отвечают за создание объектов.
Структурные – отвечают за построение иерархий классов.
Поведенческие – решают задачи эффективного взаимодействия между объектами.
 
Понимание и применение паттернов проектирования позволяет разработчикам проектировать более чистый, эффективный и масштабируемый код, что делает их важным инструментом.
 
`Module` – структурный паттерн, задачей которого является предоставление возможности инкапсуляции в JavaScript. С помощью модулей можно эмулировать приватные методы объектов. 
 
Module предоставляет способ создания модулей, ограничивая видимость переменных и функций внутри модуля, что способствует изоляции кода и предотвращает конфликты имен.
 
`Singleton` – порождающий паттерн, позволяющий использовать один экземпляр объекта класса в любом месте кода без необходимости его пересоздания. Таким образом создается меньше объектов, что уменьшает нагрузку на память. Этот паттерн подходит для реализации компонентов, используемых в разных частях программы (сервисы доступа к базам данных, кэширования, настройки приложения).
 
Singleton используется тогда, когда в приложении должен быть только один экземпляр определенного класса, и его глобальная доступность важна для обеспечения централизованного управления определенным ресурсом или состоянием.
 
`Adapter(Wrapper)` – структурный паттерн, позволяет объектам с несовместимыми интерфейсами работать вместе. Это достигается путем создания адаптера, который выступает в качестве посредника между двумя объектами, преобразуя интерфейс одного объекта в интерфейс, ожидаемый другим.
 
Adapter используется, когда требуется совместное использование двух объектов с несовместимыми интерфейсами, и создание нового класса для согласования интерфейсов не представляется возможным или целесообразным.
 
`Decorator` - структурный паттерн, позволяет добавлять объектам новое поведение или функционал, не изменяя исходный код этих объектов. Он используется для динамического расширения функциональности объектов, предоставляя гибкую альтернативу наследованию.
 
Decorator используется, когда требуется добавить дополнительное поведение объекту без переписывания существующего кода. Он облегчает расширение и изменение функциональности существующих объектов, делая код более гибким и удобным для использования.
 
Таким образом, основное различие между паттернами Adapter и Decorator состоит в их назначении: Adapter используется для обеспечения совместимости между объектами с несовместимыми интерфейсами, в то время как Decorator используется для динамического расширения функциональности объектов без изменения их исходного кода.
 
`Strategy` – поведенческий паттерн, определяет схожие алгоритмы и помещает их в разные классы, после чего эти алгоритмы можно взаимозаменять во время исполнения программы. Этот паттерн отделяет алгоритмы от контекста, что позволяет проще их изменять и добавлять новые.
 
Этот паттерн часто используется в ситуациях, когда необходимо иметь возможность изменять или выбирать различные алгоритмы во время выполнения программы, например, в разработке игр, при работе с графическими интерфейсами или веб-приложениями.
 
`Command` – поведенческий паттерн, превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций. 
 
Этот паттерн часто используется в ситуациях, когда необходимо реализовать отмену операций, создание очереди запросов, управление параллельными операциями или регистрация запросов. Например, команды могут использоваться в текстовых редакторах для отмены или повтора действий, а также в системах управления задачами.
 
`Observer (наблюдатель)` - поведенческий паттерн, который устанавливает отношение "один ко многим" между объектами, таким образом, когда состояние одного объекта изменяется, все зависимые от него объекты уведомляются и обновляются автоматически. 
 
Этот паттерн широко используется в ситуациях, где один объект должен уведомлять множество других объектов об изменении своего состояния, например, в событийно-ориентированных системах, веб-разработке, при создании пользовательских интерфейсов или при работе с базами данных.
 
`Chain of Responsibility (цепочка обязанностей)` - поведенческий паттерн, который позволяет передавать запросы по цепочке обработчиков, причем каждый обработчик решает, обрабатывать запрос или передавать его дальше по цепи. 
 
Этот паттерн используется в ситуациях, когда необходимо динамически назначать обработчиков запросов без явного указания получателя. Например, веб-фреймворки используют паттерн Chain of Responsibility для обработки HTTP-запросов, а также в системах обработки ошибок или логгирования.
 
В общем, оба паттерна могут использоваться для реализации поддержки слабосвязанных систем и упрощения процесса взаимодействия между объектами.
 
*********************************************************************************************************
 
`SOLID` - пять основных принципов объектно-ориентированного программирования, разработанных Робертом Мартином:
 
S - *Принцип единственной ответственности* (Single Responsibility Principle) - класс должен иметь только одну причину для изменения. 
Это означает, что класс должен быть ответственным только за одну часть функциональности или поведения программы.
 
O - *Принцип открытости/закрытости* (Open/Closed Principle) - программные сущности должны быть открыты для расширения, но закрыты для модификации. 
Это означает, что поведение класса должно быть изменяемым без изменения его исходного кода.
 
L - *Принцип подстановки Барбары Лисков* (Liskov Substitution Principle) - подклассы должны быть заменяемыми на свои базовые классы без изменений свойств программы. 
Это означает, что если у нас есть класс и от него наследуется другой класс, то любой объект базового класса должен быть заменяем любым объектом наследника без изменения свойств программы.
 
I - *Принцип разделения интерфейса* (Interface Segregation Principle) - клиенты не должны зависеть от интерфейсов, которые они не используют. 
Принцип говорит о том, что интерфейсы должны быть мелкими и специализированными, чтобы избежать "толстых" и "громоздких" интерфейсов.
 
D - *Принцип инверсии зависимостей* (Dependency Inversion Principle) - классы должны зависеть от абстракций, а не от конкретных реализаций. 
Это означает, что модули верхнего уровня не должны зависеть от модулей нижнего уровня, а оба типа модулей должны зависеть от абстракций.
 
*********************************************************************************************************